menuconfig STM32F1X_USB
bool "STM32F1X USB Device Library"
depends on STM32F1X
depends on HAS_USB || HAS_OTG
help
	Select this, if you want to compile the USB device
	libraries shipped by ST. 

if STM32F1X_USB

   if HAS_OTG
   comment "NB: This MCU has OTG IP Core!"
   comment "TODO: CL USB-OTG MENUCONFIG HERE!"

   endif

   if HAS_USB
   comment "NB: This MCU has USB Device IP Core!"
   

   menu "IMR_MSK bits"
   comment "Enable interrupts you wish to handle"
   
   config IMR_CNTR_CTRM
   bool "Correct TRansfer"
   default y

   config IMR_CNTR_DOVRM
   bool "DMA OVeR/underrun"

   config IMR_CNTR_ERRM
   bool "ERRor"
   
   config IMR_CNTR_WKUPM
   bool "WaKe UP"

   config IMR_CNTR_SUSPM
   bool "SUSPend"

   config IMR_CNTR_RESETM
   bool "RESET"
   default y

   config IMR_CNTR_SOFM
   bool "Start Of Frame"
   default y

   config IMR_CNTR_ESOFM
   bool "Expected Start Of Frame"

   endmenu

   config STM32_USB_HI
   bool "Use higher level API"
   select STM32_LIB_RCC
   default y
   help
	Select this to use higher level API
	taken from ST's example projects. 
	Picking this one, will automatically add
	* All needed ISR routines
	* Automatically enable USB PLL & Clocks
	* Provide some expected USB structures and callbacks
	Unless you're making anything specific, say 'y' here
   

   config USB_EP_NUM
   int "Number of endpoints"
   default 2

   config STM32_USB_MAX_PACKET_SIZE
   hex "Maximum packet size"
   default 0x40

   menu "CTR Service Routines"
   #visible if STM32_USB_HI
   # Autogenerated by scripts/trash/gen_stm_usb_ep_kcnf
   # I'm not dumb to do it by hand =)

   config USB_EP1_IN_E
   bool "EP1 IN"

   if USB_EP1_IN_E
   config USB_EP1_IN_HNDL
   string "EP1 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP1_OUT_E
   bool "EP1 OUT"

   if USB_EP1_OUT_E
   config USB_EP1_OUT_HNDL
   string "EP1 OUT Handler"
   default "NOP_Process"
   endif   

   config USB_EP2_IN_E
   bool "EP2 IN"

   if USB_EP2_IN_E
   config USB_EP2_IN_HNDL
   string "EP2 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP2_OUT_E
   bool "EP2 OUT"

   if USB_EP2_OUT_E
   config USB_EP2_OUT_HNDL
   string "EP2 OUT Handler"
   default "NOP_Process"
   endif   

   config USB_EP3_IN_E
   bool "EP3 IN"

   if USB_EP3_IN_E
   config USB_EP3_IN_HNDL
   string "EP3 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP3_OUT_E
   bool "EP3 OUT"

   if USB_EP3_OUT_E
   config USB_EP3_OUT_HNDL
   string "EP3 OUT Handler"
   default "NOP_Process"
   endif   

   config USB_EP4_IN_E
   bool "EP4 IN"

   if USB_EP4_IN_E
   config USB_EP4_IN_HNDL
   string "EP4 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP4_OUT_E
   bool "EP4 OUT"

   if USB_EP4_OUT_E
   config USB_EP4_OUT_HNDL
   string "EP4 OUT Handler"
   default "NOP_Process"
   endif   

   config USB_EP5_IN_E
   bool "EP5 IN"

   if USB_EP5_IN_E
   config USB_EP5_IN_HNDL
   string "EP5 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP5_OUT_E
   bool "EP5 OUT"

   if USB_EP5_OUT_E
   config USB_EP5_OUT_HNDL
   string "EP5 OUT Handler"
   default "NOP_Process"
   endif   

   config USB_EP6_IN_E
   bool "EP6 IN"

   if USB_EP6_IN_E
   config USB_EP6_IN_HNDL
   string "EP6 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP6_OUT_E
   bool "EP6 OUT"

   if USB_EP6_OUT_E
   config USB_EP6_OUT_HNDL
   string "EP6 OUT Handler"
   default "NOP_Process"
   endif   

   config USB_EP7_IN_E
   bool "EP7 IN"

   if USB_EP7_IN_E
   config USB_EP7_IN_HNDL
   string "EP7 IN Handler"
   default "NOP_Process"
   endif   

   config USB_EP7_OUT_E
   bool "EP7 OUT"

   if USB_EP7_OUT_E
   config USB_EP7_OUT_HNDL
   string "EP7 OUT Handler"
   default "NOP_Process"
   endif   

   endmenu

   menu "Device Descriptor"

   config STM32_USB_BCDUSB_LO
   hex "bcdUSB (Low)"
   range 0x0 0xff
   default 0x0

   config STM32_USB_BCDUSB_HI
   hex "bcdUSB (High)"
   range 0x0 0xff
   default 0x2

   config STM32_USB_BCDDEV_LO
   hex "bcdDevice (Low)"
   range 0x0 0xff
   default 0x0

   config STM32_USB_BCDDEV_HI
   hex "bcdDevice (High)"
   range 0x0 0xff
   default 0x2


   config STM32_USB_DEVCLASS
   hex "Device Class"
   range 0x0 0xff
   default 0x2

   config STM32_USB_DEVCLASS
   hex "Device Class"
   range 0x0 0xff
   default 0x2
   
   config STM32_USB_DEVSUBCLASS
   hex "Device SubClass"
   range 0x0 0xff
   default 0x0

   config STM32_USB_DEVPROTO
   hex "Device Protocol"
   range 0x0 0xff
   default 0x0
   
   config STM32_USB_VID_LO
   hex "Vendor ID (Low byte)"
   range 0x0 0xff
   default 0x83

   config STM32_USB_VID_HI
   hex "Vendor ID (High byte)"
   range 0x0 0xff
   default 0x04

   config STM32_USB_PID_LO
   hex "Product ID (Low byte)"
   range 0x0 0xff
   default 0x40

   config STM32_USB_PID_HI
   hex "Product ID (High byte)"
   range 0x0 0xff
   default 0x57
   
   config STM32_USB_CONFNUM
   int "Number of configurations"
   range 0 255
   default 1
   
   config STM32_USB_MIDX
   int "Manufacturer string index"
   range 0 255
   default 1

   config STM32_USB_PIDX
   int "Product string index"
   range 0 255
   default 2

   config STM32_USB_SIDX
   int "Serial number string index"
   range 0 255
   default 3

   endmenu
   
   menu "Standard Requests"
   config STM32_USB_RQ_usb_device_getconfiguration_en
   bool "Implement usb_device_getconfiguration"
   if STM32_USB_RQ_usb_device_getconfiguration_en
   config STM32_USB_RQ_usb_device_getconfiguration
   string "usb_device_getconfiguration handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_setconfiguration_en
   bool "Implement usb_device_setconfiguration"
   if STM32_USB_RQ_usb_device_setconfiguration_en
   config STM32_USB_RQ_usb_device_setconfiguration
   string "usb_device_setconfiguration handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_getinterface_en
   bool "Implement usb_device_getinterface"
   if STM32_USB_RQ_usb_device_getinterface_en
   config STM32_USB_RQ_usb_device_getinterface
   string "usb_device_getinterface handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_setinterface_en
   bool "Implement usb_device_setinterface"
   if STM32_USB_RQ_usb_device_setinterface_en
   config STM32_USB_RQ_usb_device_setinterface
   string "usb_device_setinterface handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_getstatus_en
   bool "Implement usb_device_getstatus"
   if STM32_USB_RQ_usb_device_getstatus_en
   config STM32_USB_RQ_usb_device_getstatus
   string "usb_device_getstatus handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_clearfeature_en
   bool "Implement usb_device_clearfeature"
   if STM32_USB_RQ_usb_device_clearfeature_en
   config STM32_USB_RQ_usb_device_clearfeature
   string "usb_device_clearfeature handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_setendpointfeature_en
   bool "Implement usb_device_setendpointfeature"
   if STM32_USB_RQ_usb_device_setendpointfeature_en
   config STM32_USB_RQ_usb_device_setendpointfeature
   string "usb_device_setendpointfeature handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_setdevicefeature_en
   bool "Implement usb_device_setdevicefeature"
   if STM32_USB_RQ_usb_device_setdevicefeature_en
   config STM32_USB_RQ_usb_device_setdevicefeature
   string "usb_device_setdevicefeature handler"
   default "NOP_Process"
   endif
   config STM32_USB_RQ_usb_device_setdeviceaddress_en
   bool "Implement usb_device_setdeviceaddress"
   if STM32_USB_RQ_usb_device_setdeviceaddress_en
   config STM32_USB_RQ_usb_device_setdeviceaddress
   string "usb_device_setdeviceaddress handler"
   default "NOP_Process"
   endif

   endmenu

   menu "Interfaces and altsettings"

   config STM32_USB_ALTNUM
   int "Number of altsettings"
   default 1

   config STM32_USB_IFACENUM
   int "Number of interfaces"
   default 1

   endmenu
   
   menu "String Descriptors"
   

   config STM32_USB_STR_DSC_DYNAMIC
   bool "Support dynamic string descriptors"
   help
	This option adds support for dynamic string descriptor
	generation. 
	With this enabled, you should implement the following callback
	uint8_t* usb_device_get_dynamic_string(uint8_t idx);
	which will be called when the host asks for a string index, that is 
	not present in the static table. 
	Return a pointer to an ASCII string (it will be compiled to unicode)
	or NULL, if that index does not exist. 

   
   config STM32_USB_STR_DSC_COUNT
   int "String Descriptor count"
   range 0 256
   default 3
   help
	The number of USB String descriptors from the 
	following table to be compiled in the firmware
	Default is only for vendor, product, serial

   source "antares/src/arch/arm/stm32/usb-f1x/strings.kcnf"
   
   endmenu

   endif

   
   
   	
endif

