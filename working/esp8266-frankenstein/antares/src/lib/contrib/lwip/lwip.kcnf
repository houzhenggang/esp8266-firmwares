menu "Platform specific locking"

config LWIP_SYS_LIGHTWEIGHT_PROT
bool "Lightweight inter-task protection"
default n 
help
	/**
	* SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
	* critical regions during buffer allocation, deallocation and memory
	* allocation and deallocation.
	*/

config LWIP_NO_SYS
bool "No-System mode (for bare metal target)"
default n 
help
	/**
	* NO_SYS==1: Provides VERY minimal functionality. Otherwise,
	* use lwIP facilities.
	*/

config LWIP_NO_SYS_NO_TIMERS
bool "Drop support for sys_timeout on no_sys"
depends on NO_SYS
default n 
help
	/**
	* NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
	* Mainly for compatibility to old versions.
	*/

#config LWIP_MEMCPY(dst,src,len)
#int "LWIP_MEMCPY(dst,src,len)"
#help
#	/**
#	* MEMCPY: override this if you have a faster implementation at hand than the
#	* one included in your C library
#	*/

#config LWIP_SMEMCPY(dst,src,len)
#int "LWIP_SMEMCPY(dst,src,len)"
#help
#	/**
#	* SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
#	* call to memcpy() if the length is known at compile time and is small.
#	*/


endmenu 


menu "Memory options"

config LWIP_MEM_LIBC_MALLOC
bool "Use malloc/free/realloc provided by your C-library"
default n 
help
	/**
	* MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
	* instead of the lwip internal allocator. Can save code size if you
	* already use it.
	*/

config LWIP_MEMP_MEM_MALLOC
bool "Use mem_malloc/mem_free instead of the lwip pool allocator"
default n 
help
	/**
	* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
	* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
	* speed and usage from interrupts!
	*/

config LWIP_MEM_ALIGNMENT
int "CPU memory alignment in bytes"
default 4 if ARCH_ARM
default 2 if ARCH_AVR
default 2 if ARCH_MSP430
help
	/**
	* MEM_ALIGNMENT: should be set to the alignment of the CPU
	*    4 byte alignment -> #define MEM_ALIGNMENT 4
	*    2 byte alignment -> #define MEM_ALIGNMENT 2
	*/

config LWIP_MEM_SIZE
int "Heap memory size"
help
	/**
	* MEM_SIZE: the size of the heap memory. If the application will send
	* a lot of data that needs to be copied, this should be set high.
	*/

config LWIP_MEMP_SEPARATE_POOLS
bool "Place each pool in its own array"
default n 
help
	/**
	* MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
	* This can be used to individually change the location of each pool.
	* Default is one big array for all pools
	*/

config LWIP_MEMP_OVERFLOW_CHECK
int "Check for overflows in memp (see help)"
default 1
help
	/**
	* MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
	* amount of bytes before and after each memp element in every pool and fills
	* it with a prominent default value.
	*    MEMP_OVERFLOW_CHECK == 0 no checking
	*    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
	*    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
	*      memp_malloc() or memp_free() is called (useful but slow!)
	*/

config LWIP_MEMP_SANITY_CHECK
bool "Do a sanity check after each memp_free()"
default n 
help
	/**
	* MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
	* sure that there are no cycles in the linked lists.
	*/

config LWIP_MEM_USE_POOLS
bool "Use memory pools instead of malloc"
depends on LWIP_MEMP_USE_CUSTOM_POOLS
default n 
help
	/**
	* MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
	* of memory pools of various sizes. When mem_malloc is called, an element of
	* the smallest pool that can provide the length needed is returned.
	* To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
	*/

config LWIP_MEM_USE_POOLS_TRY_BIGGER_POOL
bool "Try a bigger pool if one malloc-pool is empty"
default n 
help
	/**
	* MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
	* bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
	* reliable. */

config LWIP_MEMP_USE_CUSTOM_POOLS
bool "Use custom lwippools.h"
default n 
help
	/**
	* MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
	* that defines additional pools beyond the "standard" ones required
	* by lwIP. If you set this to 1, you must have lwippools.h in your
	* inlude path somewhere.
	*/

config LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
bool "Allow mem_free() from other contexts"
default n 
help
	/**
	* Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
	* interrupt context (or another context that doesn't allow waiting for a
	* semaphore).
	* If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
	* while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
	* with each loop so that mem_free can run.
	*
	* ATTENTION: As you can see from the above description, this leads to dis-/
	* enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
	* can need longer.
	*
	* If you don't want that, at least for NO_SYS=0, you can still use the following
	* functions to enqueue a deallocation call which then runs in the tcpip_thread
	* context:
	* - pbuf_free_callback(p);
	* - mem_free_callback(m);
	*/


endmenu 


menu "Internal Memory Pool Sizes"

config LWIP_MEMP_NUM_PBUF
int "Number of memp struct pbufs"
default 16
help
	/**
	* MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
	* If the application sends a lot of data out of ROM (or other static memory),
	* this should be set high.
	*/

config LWIP_MEMP_NUM_RAW_PCB
int "Number of raw connection PCBs"
default 4
depends on LWIP_RAW
help
	/**
	* MEMP_NUM_RAW_PCB: Number of raw connection PCBs
	* (requires the LWIP_RAW option)
	*/

config LWIP_MEMP_NUM_UDP_PCB
int "Number of UDP protocol control blocks"
default 4
depends on LWIP_UDP
help
	/**
	* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
	* per active UDP "connection".
	* (requires the LWIP_UDP option)
	*/

config LWIP_MEMP_NUM_TCP_PCB
int "Number of simulatenously active TCP connections."
default 5
depends on LWIP_TCP
help
	/**
	* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
	* (requires the LWIP_TCP option)
	*/

config LWIP_MEMP_NUM_TCP_PCB_LISTEN
int "Number of listening TCP connections"
default 8
depends on LWIP_TCP
help
	/**
	* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
	* (requires the LWIP_TCP option)
	*/

config LWIP_MEMP_NUM_TCP_SEG
int "Number of simultaneously queued TCP segments"
default 16
depends on LWIP_TCP
help
	/**
	* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
	* (requires the LWIP_TCP option)
	*/

config LWIP_MEMP_NUM_REASSDATA
int "Number of IP packets queued for reassembly"
default 5
help
	/**
	* MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
	* reassembly (whole packets, not fragments!)
	*/

config LWIP_MEMP_NUM_FRAG_PBUF
default 15
int "Number of IP fragments simultaneously sent"
help
	/**
	* MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
	* (fragments, not whole packets!).
	* This is only used with IP_FRAG_USES_STATIC_BUF==0 and
	* LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
	* where the packet is not yet sent when netif->output returns.
	*/

config LWIP_MEMP_NUM_ARP_QUEUE
int "LWIP_MEMP_NUM_ARP_QUEUE"
default 30
depends on LWIP_ARP_QUEUEING
help
	/**
	* MEMP_NUM_ARP_QUEUE: the number of simulateosly queued outgoing
	* packets (pbufs) that are waiting for an ARP request (to resolve
	* their destination address) to finish.
	* (requires the ARP_QUEUEING option)
	*/

config LWIP_MEMP_NUM_IGMP_GROUP
int "Number of IGMP groups (see help)"
default 8
depends on LWIP_IGMP
help
	/**
	* MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
	* can be members at the same time (one per netif - allsystems group -, plus one
	* per netif membership).
	* (requires the LWIP_IGMP option)
	*/

config LWIP_MEMP_NUM_SYS_TIMEOUT
int "Number of simulateously active timeouts."
default 3
depends on !NO_SYS
help
	/**
	* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
	* (requires NO_SYS==0)
	*/

config LWIP_MEMP_NUM_NETBUF
int "Number of struct netbufs"
default 2
help
	/**
	* MEMP_NUM_NETBUF: the number of struct netbufs.
	* (only needed if you use the sequential API, like api_lib.c)
	*/

config LWIP_MEMP_NUM_NETCONN
int "Number of struct netconns"
default 4
help
	/**
	* MEMP_NUM_NETCONN: the number of struct netconns.
	* (only needed if you use the sequential API, like api_lib.c)
	*/

config LWIP_MEMP_NUM_TCPIP_MSG_API
int "Number of struct tcpip_msg"
default 8
help
	/**
	* MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
	* for callback/timeout API communication.
	* (only needed if you use tcpip.c)
	*/

config LWIP_MEMP_NUM_TCPIP_MSG_INPKT
int "Number of struct tcpip_msg"
default 8
help
	/**
	* MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
	* for incoming packets.
	* (only needed if you use tcpip.c)
	*/

config LWIP_MEMP_NUM_SNMP_NODE
int "Number of leafs in the SNMP tree."
default 50
help
	/**
	* MEMP_NUM_SNMP_NODE: the number of leafs in the SNMP tree.
	*/

config LWIP_MEMP_NUM_SNMP_ROOTNODE
int "LWIP_MEMP_NUM_SNMP_ROOTNODE"
default 50
help
	/**
	* MEMP_NUM_SNMP_ROOTNODE: the number of branches in the SNMP tree.
	* Every branch has one leaf (MEMP_NUM_SNMP_NODE) at least!
	*/

config LWIP_MEMP_NUM_SNMP_VARBIND
int "LWIP_MEMP_NUM_SNMP_VARBIND"
default 2
help
	/**
	* MEMP_NUM_SNMP_VARBIND: the number of concurrent requests (does not have to
	* be changed normally) - 2 of these are used per request (1 for input,
	* 1 for output)
	*/

config LWIP_MEMP_NUM_SNMP_VALUE
int "Number of OID or values concurrently used"
default 3
help
	/**
	* MEMP_NUM_SNMP_VALUE: the number of OID or values concurrently used
	* (does not have to be changed normally) - 3 of these are used per request
	* (1 for the value read and 2 for OIDs - input and output)
	*/

config LWIP_MEMP_NUM_NETDB
int "Number of concurrently running lwip_addrinfo() calls"
default 1
help
	/**
	* MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
	* (before freeing the corresponding memory using lwip_freeaddrinfo()).
	*/

config LWIP_MEMP_NUM_LOCALHOSTLIST
int "Number of host entries in the local host list"
default 1
help
	/**
	* MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
	* if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
	*/

config LWIP_MEMP_NUM_PPPOE_INTERFACES
int "Number of concurrently active PPPoE ifaces"
default 1
help
	/**
	* MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
	* interfaces (only used with PPPOE_SUPPORT==1)
	*/

config LWIP_PBUF_POOL_SIZE
int "Number of buffers in the pbuf pool."
default 16
help
	/**
	* PBUF_POOL_SIZE: the number of buffers in the pbuf pool.
	*/


endmenu 


menu "ARP options"

config LWIP_ARP
bool "Number of buffers in the pbuf pool."
default y 
help
	/**
	* LWIP_ARP==1: Enable ARP functionality.
	*/

config LWIP_ARP_TABLE_SIZE
int "Number of active MAC-IP address pairs cached"
default 10
help
	/**
	* ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
	*/

config LWIP_ARP_QUEUEING
bool "Enable ARP queueing"
default n 
help
	/**
	* ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
	* resolution. By default, only the most recent packet is queued per IP address.
	* This is sufficient for most protocols and mainly reduces TCP connection
	* startup time. Set this to 1 if you know your application sends more than one
	* packet in a row to an IP address that is not in the ARP cache.
	*/

config LWIP_ETHARP_TRUST_IP_MAC
bool "Trust MAC in incoming packets"
default n 
help
	/**
	* ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
	* updated with the source MAC and IP addresses supplied in the packet.
	* You may want to disable this if you do not trust LAN peers to have the
	* correct addresses, or as a limited approach to attempt to handle
	* spoofing. If disabled, lwIP will need to make a new ARP request if
	* the peer is not already in the ARP table, adding a little latency.
	* The peer *is* in the ARP table if it requested our address before.
	* Also notice that this slows down input processing of every IP packet!
	*/

config LWIP_ETHARP_SUPPORT_VLAN
bool "Support receiving ethernet packets with VLAN header"
default n 
help
	/**
	* ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
	* Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
	* If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
	* If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
	*/

config LWIP_ETHERNET
bool "Enable ethernet support for PPPoE even though ARP"
default n
depends on LWIP_PPPOE_SUPPORT
help
	/** LWIP_ETHERNET==1: enable ethernet support for PPPoE even though ARP
	* might be disabled
	*/

config LWIP_ETH_PAD_SIZE
int "Number of bytes added before the ethernet header"
default 0
help
	/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
	* alignment of payload after that header. Since the header is 14 bytes long,
	* without this padding e.g. addresses in the IP header will not be aligned
	* on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
	*/

config LWIP_ETHARP_SUPPORT_STATIC_ENTRIES
bool "Enable support for static ARP entries"
default n 
help
	/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
	* entries (using etharp_add_static_entry/etharp_remove_static_entry).
	*/


endmenu 


menu "IP options"

config LWIP_IP_FORWARD
bool "Enable IP forwarding"
default n 
help
	/**
	* IP_FORWARD==1: Enables the ability to forward IP packets across network
	* interfaces. If you are going to run lwIP on a device with only one network
	* interface, define this to 0.
	*/

config LWIP_IP_OPTIONS_ALLOWED
bool "Allow packets with IP options"
default y 
help
	/**
	* IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
	*      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
	*      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
	*/

config LWIP_IP_REASSEMBLY
bool "Reassemble fragmented packets"
default y 
help
	/**
	* IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
	* this option does not affect outgoing packet sizes, which can be controlled
	* via IP_FRAG.
	*/

config LWIP_IP_FRAG
bool "Fragment outgoing packets"
default y 
help
	/**
	* IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
	* that this option does not affect incoming packet sizes, which can be
	* controlled via IP_REASSEMBLY.
	*/

config LWIP_IP_REASS_MAXAGE
int "Reassembly timeout"
default 3
help
	/**
	* IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
	* a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
	* in this time, the whole packet is discarded.
	*/

config LWIP_IP_REASS_MAX_PBUFS
int "Total maximum pbufs for reassembly"
default 10
help
	/**
	* IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
	* Since the received pbufs are enqueued, be sure to configure
	* PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
	* packets even if the maximum amount of fragments is enqueued for reassembly!
	*/

config LWIP_IP_FRAG_USES_STATIC_BUF
bool "Use static buffer for fragmentation"
default n 
help
	/**
	* IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
	* fragmentation. Otherwise pbufs are allocated and reference the original
	* packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
	* new PBUF_RAM pbufs are used for fragments).
	* ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
	*/

config LWIP_IP_FRAG_MAX_MTU
int "Assumed maximum MTU"
default 1500
help
	/**
	* IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
	* (requires IP_FRAG_USES_STATIC_BUF==1)
	*/

config LWIP_IP_DEFAULT_TTL
int "Default value for Time-To-Live used by transport layers."
default 255
help
	/**
	* IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
	*/

config LWIP_IP_SOF_BROADCAST
bool "Use the SOF_BROADCAST field (see help)"
default n 
help
	/**
	* IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
	* filter per pcb on udp and raw send operations. To enable broadcast filter
	* on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
	*/

config LWIP_IP_SOF_BROADCAST_RECV
bool "Enable the broadcast filter on recv operations"
default n 
depends on LWIP_IP_SOF_BROADCAST
help
	/**
	* IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
	* filter on recv operations.
	*/

endmenu 


menu "ICMP options"

config LWIP_ICMP
bool "Enable ICMP module"
default y 
help
	/**
	* LWIP_ICMP==1: Enable ICMP module inside the IP stack.
	* Be careful, disable that make your product non-compliant to RFC1122
	*/

config LWIP_ICMP_TTL
int "LWIP_ICMP_TTL"
default 255
help
	/**
	* ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
	*/

config LWIP_BROADCAST_PING
bool "Respond to broadcast pings"
default n 
help
	/**
	* LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
	*/

config LWIP_MULTICAST_PING
bool "Respond to multicast pings"
default n 
help
	/**
	* LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
	*/


endmenu 


menu "RAW options"

config LWIP_RAW
bool "Enable application layer to hook into the IP layer"
default y 
help
	/**
	* LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
	*/

config LWIP_RAW_TTL
int "Raw TTL"
help
	/**
	* LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
	*/


endmenu 


menu "DHCP options"

config LWIP_DHCP
bool "Enable DHCP module"
default n 
help
	/**
	* LWIP_DHCP==1: Enable DHCP module.
	*/

config LWIP_DHCP_DOES_ARP_CHECK
bool "LWIP_DHCP_DOES_ARP_CHECK"
default y if LWIP_DHCP && LWIP_ARP
help
	/**
	* DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
	*/


endmenu 


menu "AUTOIP options"

config LWIP_AUTOIP
bool "Enable AUTOIP module"
default n 
help
	/**
	* LWIP_AUTOIP==1: Enable AUTOIP module.
	*/

config LWIP_DHCP_AUTOIP_COOP
bool "AutoIP & DHCP can coop on the same iface"
default n 
help
	/**
	* LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
	* the same interface at the same time.
	*/

config LWIP_DHCP_AUTOIP_COOP_TRIES
int "DHCP discover probes before autoip fallback"
default 9
help
	/**
	* LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
	* that should be sent before falling back on AUTOIP. This can be set
	* as low as 1 to get an AutoIP address very quickly, but you should
	* be prepared to handle a changing IP address when DHCP overrides
	* AutoIP.
	*/


endmenu 


menu "SNMP options"

config LWIP_SNMP
bool "Turn on SNMP module"
depends on LWIP_UDP
default n 
help
	/**
	* LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
	* transport.
	*/

config LWIP_SNMP_CONCURRENT_REQUESTS
int "Number of concurrent requests allowed"
default 1 
help
	/**
	* SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
	* allow. At least one request buffer is required.
	* Does not have to be changed unless external MIBs answer request asynchronously
	*/

config LWIP_SNMP_TRAP_DESTINATIONS
int "Number of trap destinations"
default 1
help
	/**
	* SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
	* destination is required
	*/

config LWIP_SNMP_PRIVATE_MIB
bool "Use a private MIB"
default n 
help
	/**
	* SNMP_PRIVATE_MIB:
	* When using a private MIB, you have to create a file 'private_mib.h' that contains
	* a 'struct mib_array_node mib_private' which contains your MIB.
	*/

config LWIP_SNMP_SAFE_REQUESTS
bool "Only allow SNMP write actions that are 'safe'"
default y 
help
	/**
	* Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
	* a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
	* Unsafe requests are disabled by default!
	*/

config LWIP_SNMP_MAX_OCTET_STRING_LEN
int "LWIP_SNMP_MAX_OCTET_STRING_LEN"
default 127
help
	/**
	* The maximum length of strings used. This affects the size of
	* MEMP_SNMP_VALUE elements.
	*/

config LWIP_SNMP_MAX_TREE_DEPTH
int "The maximum depth of the SNMP tree"
default 15
help
	/**
	* The maximum depth of the SNMP tree.
	* With private MIBs enabled, this depends on your MIB!
	* This affects the size of MEMP_SNMP_VALUE elements.
	*/

config LWIP_SNMP_MAX_VALUE_SIZE_OVR
bool "Override default size of the MEMP_SNMP_VALUE elements"
default n

if LWIP_SNMP_MAX_VALUE_SIZE_OVR
config LWIP_SNMP_MAX_VALUE_SIZE
int "The size of the MEMP_SNMP_VALUE elements"
default 1
help
	/**
	* The size of the MEMP_SNMP_VALUE elements, normally calculated from
	* SNMP_MAX_OCTET_STRING_LEN and SNMP_MAX_TREE_DEPTH.
	*/
endif

endmenu 


menu "IGMP options"

config LWIP_IGMP
bool "Turn on IGMP"
default n 
help
	/**
	* LWIP_IGMP==1: Turn on IGMP module.
	*/


endmenu 


menu "DNS options"

config LWIP_DNS
bool "Turn on DNS module"
depends on LWIP_UDP
default n 
help
	/**
	* LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
	* transport.
	*/

config LWIP_DNS_TABLE_SIZE
int "LWIP_DNS_TABLE_SIZE"
default 4
help
	/** DNS maximum number of entries to maintain locally. */

config LWIP_DNS_MAX_NAME_LENGTH
int "DNS maximum host name length"
default 256
help
	/** DNS maximum host name length supported in the name table. */

config LWIP_DNS_MAX_SERVERS
int "The maximum number of DNS servers"
default 2
help
	/** The maximum of DNS servers */

config LWIP_DNS_DOES_NAME_CHECK
bool "DNS do a name checking between the query and the response."
default y 
help
	/** DNS do a name checking between the query and the response. */

config LWIP_DNS_MSG_SIZE
int "DNS message max. size"
default 512
help
	/** DNS message max. size. Default value is RFC compliant. */

config LWIP_DNS_LOCAL_HOSTLIST
bool "Implement a local host-to-address list"
default n 
help
	/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
	*  you have to define
	*    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
	*  (an array of structs name/address, where address is an u32_t in network
	*  byte order).
	*
	*  Instead, you can also use an external function:
	*  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
	*  that returns the IP address or INADDR_NONE if not found.
	*/

config LWIP_DNS_LOCAL_HOSTLIST_IS_DYNAMIC
bool "Local hostlist is dynamic"
default n 
help
	/** If this is turned on, the local host-list can be dynamically changed
	*  at runtime. */


endmenu 


menu "UDP options"

config LWIP_UDP
bool "Turn on UDP"
default y 
help
	/**
	* LWIP_UDP==1: Turn on UDP.
	*/

config LWIP_UDPLITE
bool "Turn on UDP-Lite"
default n 
help
	/**
	* LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
	*/

config LWIP_UDP_TTL
int "Default Time-To-Live value"
default 255
help
	/**
	* UDP_TTL: Default Time-To-Live value.
	*/

config LWIP_NETBUF_RECVINFO
bool "Append destination addr and port to every netbuf."
default n 
help
	/**
	* LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
	*/


endmenu 


menu "TCP options"

config LWIP_TCP
bool "Turn on TCP"
default y 
help
	/**
	* LWIP_TCP==1: Turn on TCP.
	*/

config LWIP_TCP_TTL
int "Default Time-To-Live value"
default 255
help
	/**
	* TCP_TTL: Default Time-To-Live value.
	*/

config LWIP_TCP_WND_O
bool "Override default TCP window size"
default n 

if LWIP_TCP_WND_O
config LWIP_TCP_WND
int "The size of a TCP window"
help
	/**
	* TCP_WND: The size of a TCP window.  This must be at least
	* (2 * TCP_MSS) for things to work well
	*/
endif 

config LWIP_TCP_MAXRTX
int "Maximum number of retransmissions of data segments"
default 12
help
	/**
	* TCP_MAXRTX: Maximum number of retransmissions of data segments.
	*/

config LWIP_TCP_SYNMAXRTX
int "Maximum number of retransmissions of SYN segments."
default 6
help
	/**
	* TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
	*/

config LWIP_TCP_QUEUE_OOSEQ
bool "Queue segments that arrive out of order"
default n
help
	/**
	* TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
	* Define to 0 if your device is low on memory.
	*/

config LWIP_TCP_MSS
int "TCP Maximum segment size"
default 536
help
	/**
	* TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
	* you might want to increase this.)
	* For the receive side, this MSS is advertised to the remote side
	* when opening a connection. For the transmit size, this MSS sets
	* an upper limit on the MSS advertised by the remote host.
	*/

config LWIP_TCP_CALCULATE_EFF_SEND_MSS
bool "EFF calculation"
default y 
help
	/**
	* TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
	* sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
	* reflects the available reassembly buffer size at the remote host) and the
	* largest size permitted by the IP layer" (RFC 1122)
	* Setting this to 1 enables code that checks TCP_MSS against the MTU of the
	* netif used for a connection and limits the MSS if it would be too big otherwise.
	*/

config LWIP_TCP_SND_BUF
int "TCP sender buffer space (bytes)"
default 256
help
	/**
	* TCP_SND_BUF: TCP sender buffer space (bytes).
	*/

#config LWIP_TCP_SND_QUEUELEN
#int "LWIP_TCP_SND_QUEUELEN"
#help
#	/**
#	* TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
#	* as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
#	*/

#config LWIP_TCP_SNDLOWAT
#int "LWIP_TCP_SNDLOWAT"
#help
#	/**
#	* TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
#	* TCP_SND_BUF. It is the amount of space which must be available in the
#	* TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
#	*/

#config LWIP_TCP_SNDQUEUELOWAT
#int "LWIP_TCP_SNDQUEUELOWAT"
#help
#	/**
#	* TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be grater
#	* than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
#	* this number, select returns writable (combined with TCP_SNDLOWAT).
#	*/

config LWIP_TCP_LISTEN_BACKLOG
bool "TCP_LISTEN_BACKLOG"
default n 
help
	/**
	* TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
	*/

#config LWIP_TCP_DEFAULT_LISTEN_BACKLOG
#int "LWIP_TCP_DEFAULT_LISTEN_BACKLOG"
#help
#	/**
#	* The maximum allowed backlog for TCP listen netconns.
#	* This backlog is used unless another is explicitly specified.
#	* 0xff is the maximum (u8_t).
#	*/

#config LWIP_TCP_OVERSIZE
#int "LWIP_TCP_OVERSIZE"
#help
#	/**
#	* TCP_OVERSIZE: The maximum number of bytes that tcp_write may
#	* allocate ahead of time in an attempt to create shorter pbuf chains
#	* for transmission. The meaningful range is 0 to TCP_MSS. Some
#	* suggested values are:
#	*
#	* 0:         Disable oversized allocation. Each tcp_write() allocates a new
#	pbuf (old behaviour).
#	* 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
#	*            scatter-gather DMA requires aligned fragments.
#	* 128:       Limit the pbuf/memory overhead to 20%.
#	* TCP_MSS:   Try to create unfragmented TCP packets.
#	* TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
#	*/

config LWIP_TCP_TIMESTAMPS
bool "LWIP_TCP_TIMESTAMPS"
default n 
help
	/**
	* LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
	*/

#config LWIP_TCP_WND_UPDATE_THRESHOLD
#int "LWIP_TCP_WND_UPDATE_THRESHOLD"
#help
#	/**
#	* TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
#	* explicit window update
#	*/

config LWIP_EVENT_API
bool "LWIP_EVENT_API"
default n 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/

config LWIP_CALLBACK_API
bool "LWIP_CALLBACK_API"
default y 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/

config LWIP_EVENT_API
bool "LWIP_EVENT_API"
default y 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/

config LWIP_CALLBACK_API
bool "LWIP_CALLBACK_API"
default n 
help
	/**
	* LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
	*     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
	*         events (accept, sent, etc) that happen in the system.
	*     LWIP_CALLBACK_API==1: The PCB callback function is called directly
	*         for the event.
	*/


endmenu 


menu "Pbuf options"

#config LWIP_PBUF_LINK_HLEN
#int "LWIP_PBUF_LINK_HLEN"
#help
#	/**
#	* PBUF_LINK_HLEN: the number of bytes that should be allocated for a
#	* link level header. The default is 14, the standard value for
#	* Ethernet.
#	*/

#config LWIP_PBUF_POOL_BUFSIZE
#int "LWIP_PBUF_POOL_BUFSIZE"
#help
#	/**
#	* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
#	* designed to accomodate single full size TCP frame in one pbuf, including
#	* TCP_MSS, IP header, and link header.
#	*/


endmenu 


menu "Network Interfaces options"

config LWIP_NETIF_HOSTNAME
bool "LWIP_NETIF_HOSTNAME"
default n 
help
	/**
	* LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
	* field.
	*/

config LWIP_NETIF_API
bool "LWIP_NETIF_API"
default n 
help
	/**
	* LWIP_NETIF_API==1: Support netif api (in netifapi.c)
	*/

config LWIP_NETIF_STATUS_CALLBACK
bool "LWIP_NETIF_STATUS_CALLBACK"
default n 
help
	/**
	* LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
	* changes its up/down status (i.e., due to DHCP IP acquistion)
	*/

config LWIP_NETIF_LINK_CALLBACK
bool "LWIP_NETIF_LINK_CALLBACK"
default n 
help
	/**
	* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
	* whenever the link changes (i.e., link down)
	*/

config LWIP_NETIF_HWADDRHINT
bool "LWIP_NETIF_HWADDRHINT"
default n 
help
	/**
	* LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
	* indices) in struct netif. TCP and UDP can make use of this to prevent
	* scanning the ARP table for every sent packet. While this is faster for big
	* ARP tables or many concurrent connections, it might be counterproductive
	* if you have a tiny ARP table or if there never are concurrent connections.
	*/

config LWIP_NETIF_LOOPBACK
bool "LWIP_NETIF_LOOPBACK"
default n 
help
	/**
	* LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
	* address equal to the netif IP address, looping them back up the stack.
	*/

config LWIP_LOOPBACK_MAX_PBUFS
bool "LWIP_LOOPBACK_MAX_PBUFS"
default n 
help
	/**
	* LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
	* sending for each netif (0 = disabled)
	*/

#config LWIP_NETIF_LOOPBACK_MULTITHREADING
#int "LWIP_NETIF_LOOPBACK_MULTITHREADING"
#help
#	/**
#	* LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
#	* the system, as netifs must change how they behave depending on this setting
#	* for the LWIP_NETIF_LOOPBACK option to work.
#	* Setting this is needed to avoid reentering non-reentrant functions like
#	* tcp_input().
#	*    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
#	*       multithreaded environment like tcpip.c. In this case, netif->input()
#	*       is called directly.
#	*    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
#	*       The packets are put on a list and netif_poll() must be called in
#	*       the main application loop.
#	*/

config LWIP_NETIF_TX_SINGLE_PBUF
bool "LWIP_NETIF_TX_SINGLE_PBUF"
default n 
help
	/**
	* LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
	* to be sent into one single pbuf. This is for compatibility with DMA-enabled
	* MACs that do not support scatter-gather.
	* Beware that this might involve CPU-memcpy before transmitting that would not
	* be needed without this flag! Use this only if you need to!
	*
	* @todo: TCP and IP-frag do not work with this, yet:
	*/


endmenu 


menu "LOOPIF options"

config LWIP_HAVE_LOOPIF
bool "LWIP_HAVE_LOOPIF"
default n 
help
	/**
	* LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
	*/


endmenu 


menu "SLIPIF options"

config LWIP_HAVE_SLIPIF
bool "LWIP_HAVE_SLIPIF"
default n 
help
	/**
	* LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
	*/


endmenu 


menu "Thread options"

config LWIP_TCPIP_THREAD_NAME
string "TCPIP_THREAD_NAME"
default "tcpip_thread"
help
	/**
	* TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
	*/

config LWIP_TCPIP_THREAD_STACKSIZE
bool "TCPIP_THREAD_STACKSIZE"
default n 
help
	/**
	* TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_TCPIP_THREAD_PRIO
bool "TCPIP_THREAD_PRIO"
default y 
help
	/**
	* TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_TCPIP_MBOX_SIZE
bool "TCPIP_MBOX_SIZE"
default n 
help
	/**
	* TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
	* The queue size value itself is platform-dependent, but is passed to
	* sys_mbox_new() when tcpip_init is called.
	*/

config LWIP_SLIPIF_THREAD_NAME
string "SLIPIF_THREAD_NAME"
default "slipif_loop"
help
	/**
	* SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
	*/

config LWIP_SLIPIF_THREAD_STACKSIZE
bool "SLIPIF_THREAD_STACKSIZE"
default n 
help
	/**
	* SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_SLIPIF_THREAD_PRIO
bool "SLIPIF_THREAD_PRIO"
default y 
help
	/**
	* SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_PPP_THREAD_NAME
string "PPP_THREAD_NAME"
default "pppInputThread"
help
	/**
	* PPP_THREAD_NAME: The name assigned to the pppInputThread.
	*/

config LWIP_PPP_THREAD_STACKSIZE
bool "PPP_THREAD_STACKSIZE"
default n 
help
	/**
	* PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_PPP_THREAD_PRIO
bool "PPP_THREAD_PRIO"
default y 
help
	/**
	* PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_DEFAULT_THREAD_NAME
string "DEFAULT_THREAD_NAME"
default "lwIP"
help
	/**
	* DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
	*/

config LWIP_DEFAULT_THREAD_STACKSIZE
bool "DEFAULT_THREAD_STACKSIZE"
default n 
help
	/**
	* DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
	* The stack size value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_DEFAULT_THREAD_PRIO
bool "DEFAULT_THREAD_PRIO"
default y 
help
	/**
	* DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
	* The priority value itself is platform-dependent, but is passed to
	* sys_thread_new() when the thread is created.
	*/

config LWIP_DEFAULT_RAW_RECVMBOX_SIZE
bool "DEFAULT_RAW_RECVMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
	* NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
	* to sys_mbox_new() when the recvmbox is created.
	*/

config LWIP_DEFAULT_UDP_RECVMBOX_SIZE
bool "DEFAULT_UDP_RECVMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
	* NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
	* to sys_mbox_new() when the recvmbox is created.
	*/

config LWIP_DEFAULT_TCP_RECVMBOX_SIZE
bool "DEFAULT_TCP_RECVMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
	* NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
	* to sys_mbox_new() when the recvmbox is created.
	*/

config LWIP_DEFAULT_ACCEPTMBOX_SIZE
bool "DEFAULT_ACCEPTMBOX_SIZE"
default n 
help
	/**
	* DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
	* The queue size value itself is platform-dependent, but is passed to
	* sys_mbox_new() when the acceptmbox is created.
	*/


endmenu 


menu "Sequential layer options"

config LWIP_TCPIP_CORE_LOCKING
bool "LWIP_TCPIP_CORE_LOCKING"
default n 
help
	/**
	* LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
	* Don't use it if you're not an active lwIP project member
	*/

config LWIP_TCPIP_CORE_LOCKING_INPUT
bool "LWIP_TCPIP_CORE_LOCKING_INPUT"
default n 
help
	/**
	* LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
	* Don't use it if you're not an active lwIP project member
	*/

config LWIP_NETCONN
bool "LWIP_NETCONN"
default y 
help
	/**
	* LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
	*/

config LWIP_TCPIP_TIMEOUT
bool "LWIP_TCPIP_TIMEOUT"
default y 
help
	/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
	* timers running in tcpip_thread from another thread.
	*/


endmenu 


menu "Socket options"

config LWIP_SOCKET
bool "LWIP_SOCKET"
default y 
help
	/**
	* LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
	*/

config LWIP_COMPAT_SOCKETS
bool "LWIP_COMPAT_SOCKETS"
default y 
help
	/**
	* LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
	* (only used if you use sockets.c)
	*/

config LWIP_POSIX_SOCKETS_IO_NAMES
bool "LWIP_POSIX_SOCKETS_IO_NAMES"
default y 
help
	/**
	* LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
	* Disable this option if you use a POSIX operating system that uses the same
	* names (read, write & close). (only used if you use sockets.c)
	*/

config LWIP_TCP_KEEPALIVE
bool "LWIP_TCP_KEEPALIVE"
default n 
help
	/**
	* LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
	* options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
	* in seconds. (does not require sockets.c, and will affect tcp.c)
	*/

config LWIP_SO_RCVTIMEO
bool "LWIP_SO_RCVTIMEO"
default n 
help
	/**
	* LWIP_SO_RCVTIMEO==1: Enable SO_RCVTIMEO processing.
	*/

config LWIP_SO_RCVBUF
bool "LWIP_SO_RCVBUF"
default n 
help
	/**
	* LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
	*/

#config LWIP_RECV_BUFSIZE_DEFAULT
#int "LWIP_RECV_BUFSIZE_DEFAULT"
#help
#	/**
#	* If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
#	*/

config LWIP_SO_REUSE
bool "SO_REUSE"
default n 
help
	/**
	* SO_REUSE==1: Enable SO_REUSEADDR option.
	*/

config LWIP_SO_REUSE_RXTOALL
bool "SO_REUSE_RXTOALL"
default n 
help
	/**
	* SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
	* to all local matches if SO_REUSEADDR is turned on.
	* WARNING: Adds a memcpy for every packet if passing to more than one pcb!
	*/


endmenu 


menu "Statistics options"

config LWIP_STATS
bool "LWIP_STATS"
default y 
help
	/**
	* LWIP_STATS==1: Enable statistics collection in lwip_stats.
	*/

config LWIP_STATS_DISPLAY
bool "LWIP_STATS_DISPLAY"
default n 
help
	/**
	* LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
	*/

config LWIP_LINK_STATS
bool "LINK_STATS"
default y 
help
	/**
	* LINK_STATS==1: Enable link stats.
	*/

#config LWIP_ETHARP_STATS
#int "LWIP_ETHARP_STATS"
#help
#	/**
#	* ETHARP_STATS==1: Enable etharp stats.
#	*/

config LWIP_IP_STATS
bool "IP_STATS"
default y 
help
	/**
	* IP_STATS==1: Enable IP stats.
	*/

#config LWIP_IPFRAG_STATS
#int "LWIP_IPFRAG_STATS"
#help
#	/**
#	* IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
#	* on if using either frag or reass.
#	*/

config LWIP_ICMP_STATS
bool "ICMP_STATS"
default y 
help
	/**
	* ICMP_STATS==1: Enable ICMP stats.
	*/

#config LWIP_IGMP_STATS
#int "LWIP_IGMP_STATS"
#help
#	/**
#	* IGMP_STATS==1: Enable IGMP stats.
#	*/

#config LWIP_UDP_STATS
#int "LWIP_UDP_STATS"
#help
#	/**
#	* UDP_STATS==1: Enable UDP stats. Default is on if
#	* UDP enabled, otherwise off.
#	*/

#config LWIP_TCP_STATS
#int "LWIP_TCP_STATS"
#help
#	/**
#	* TCP_STATS==1: Enable TCP stats. Default is on if TCP
#	* enabled, otherwise off.
#	*/

#config LWIP_MEM_STATS
#int "LWIP_MEM_STATS"
#help
#	/**
#	* MEM_STATS==1: Enable mem.c stats.
#	*/

#config LWIP_MEMP_STATS
#int "LWIP_MEMP_STATS"
#help
#	/**
#	* MEMP_STATS==1: Enable memp.c pool stats.
#	*/

#config LWIP_SYS_STATS
#int "LWIP_SYS_STATS"
#help
#	/**
#	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
#	*/

config LWIP_LINK_STATS
bool "LINK_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_IP_STATS
bool "IP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_IPFRAG_STATS
bool "IPFRAG_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_ICMP_STATS
bool "ICMP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_IGMP_STATS
bool "IGMP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_UDP_STATS
bool "UDP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_TCP_STATS
bool "TCP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_MEM_STATS
bool "MEM_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_MEMP_STATS
bool "MEMP_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_SYS_STATS
bool "SYS_STATS"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/

config LWIP_STATS_DISPLAY
bool "LWIP_STATS_DISPLAY"
default n 
help
	/**
	* SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
	*/


endmenu 


menu "PPP options"

config LWIP_PPP_SUPPORT
bool "PPP_SUPPORT"
default n 
help
	/**
	* PPP_SUPPORT==1: Enable PPP.
	*/

config LWIP_PPPOE_SUPPORT
bool "PPPOE_SUPPORT"
default n 
help
	/**
	* PPPOE_SUPPORT==1: Enable PPP Over Ethernet
	*/

#config LWIP_PPPOS_SUPPORT
#int "LWIP_PPPOS_SUPPORT"
#help
#	/**
#	* PPPOS_SUPPORT==1: Enable PPP Over Serial
#	*/

config LWIP_NUM_PPP
int "NUM_PPP"
default 1
help
	/**
	* NUM_PPP: Max PPP sessions.
	*/

config LWIP_PAP_SUPPORT
bool "PAP_SUPPORT"
default n 
help
	/**
	* PAP_SUPPORT==1: Support PAP.
	*/

config LWIP_CHAP_SUPPORT
bool "CHAP_SUPPORT"
default n 
help
	/**
	* CHAP_SUPPORT==1: Support CHAP.
	*/

config LWIP_MSCHAP_SUPPORT
bool "MSCHAP_SUPPORT"
default n 
help
	/**
	* MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
	*/

config LWIP_CBCP_SUPPORT
bool "CBCP_SUPPORT"
default n 
help
	/**
	* CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
	*/

config LWIP_CCP_SUPPORT
bool "CCP_SUPPORT"
default n 
help
	/**
	* CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
	*/

config LWIP_VJ_SUPPORT
bool "VJ_SUPPORT"
default n 
help
	/**
	* VJ_SUPPORT==1: Support VJ header compression.
	*/

config LWIP_MD5_SUPPORT
bool "MD5_SUPPORT"
default n 
help
	/**
	* MD5_SUPPORT==1: Support MD5 (see also CHAP).
	*/

#config LWIP_FSM_DEFTIMEOUT
#int "LWIP_FSM_DEFTIMEOUT"
#help
#	#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */

#config LWIP_FSM_DEFMAXTERMREQS
#int "LWIP_FSM_DEFMAXTERMREQS"
#help
#	#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */

#config LWIP_FSM_DEFMAXCONFREQS
#int "LWIP_FSM_DEFMAXCONFREQS"
#help
#	#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */

#config LWIP_FSM_DEFMAXNAKLOOPS
#int "LWIP_FSM_DEFMAXNAKLOOPS"
#help
#	#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */

#config LWIP_UPAP_DEFTIMEOUT
#int "LWIP_UPAP_DEFTIMEOUT"
#help
#	#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */

#config LWIP_UPAP_DEFREQTIME
#int "LWIP_UPAP_DEFREQTIME"
#help
#	#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */

#config LWIP_CHAP_DEFTIMEOUT
#int "LWIP_CHAP_DEFTIMEOUT"
#help
#	#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */

#config LWIP_CHAP_DEFTRANSMITS
#int "LWIP_CHAP_DEFTRANSMITS"
#help
#	#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */

config LWIP_LCP_ECHOINTERVAL
bool "LCP_ECHOINTERVAL"
default n 
help
	/* Interval in seconds between keepalive echo requests, 0 to disable. */

#config LWIP_LCP_MAXECHOFAILS
#int "LWIP_LCP_MAXECHOFAILS"
#help
#	/* Number of unanswered echo requests before failure. */

#config LWIP_PPP_MAXIDLEFLAG
#int "LWIP_PPP_MAXIDLEFLAG"
#help
#	/* Max Xmit idle time (in jiffies) before resend flag char. */

#config LWIP_PPP_MTU
#int "LWIP_PPP_MTU"
#help
#	#define PPP_MTU                         1500     /* Default MTU (size of Info field) */

#config LWIP_PPP_MAXMTU
#int "LWIP_PPP_MAXMTU"
#help
#	#define PPP_MAXMTU                      1500 /* Largest MTU we allow */

#config LWIP_PPP_MINMTU
#int "LWIP_PPP_MINMTU"
#help
#	#define PPP_MAXMTU                      1500 /* Largest MTU we allow */

#config LWIP_PPP_MRU
#int "LWIP_PPP_MRU"
#help
#	#define PPP_MRU                         1500     /* default MRU = max length of info field */

#config LWIP_PPP_MAXMRU
#int "LWIP_PPP_MAXMRU"
#help
#	#define PPP_MAXMRU                      1500     /* Largest MRU we allow */

#config LWIP_PPP_DEFMRU
#int "LWIP_PPP_DEFMRU"
#help
#	#define PPP_DEFMRU                      296             /* Try for this */

#config LWIP_PPP_MINMRU
#int "LWIP_PPP_MINMRU"
#help
#	#define PPP_MINMRU                      128             /* No MRUs below this */

#config LWIP_MAXNAMELEN
#int "LWIP_MAXNAMELEN"
#help
#	#define MAXNAMELEN                      256     /* max length of hostname or name for auth */

#config LWIP_MAXSECRETLEN
#int "LWIP_MAXSECRETLEN"
#help
#	#define MAXSECRETLEN                    256     /* max length of password or secret */


endmenu 


menu "Checksum options"

config LWIP_CHECKSUM_GEN_IP
bool "CHECKSUM_GEN_IP"
default y 
help
	/**
	* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
	*/

config LWIP_CHECKSUM_GEN_UDP
bool "CHECKSUM_GEN_UDP"
default y 
help
	/**
	* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
	*/

config LWIP_CHECKSUM_GEN_TCP
bool "CHECKSUM_GEN_TCP"
default y 
help
	/**
	* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
	*/

config LWIP_CHECKSUM_CHECK_IP
bool "CHECKSUM_CHECK_IP"
default y 
help
	/**
	* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
	*/

config LWIP_CHECKSUM_CHECK_UDP
bool "CHECKSUM_CHECK_UDP"
default y 
help
	/**
	* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
	*/

config LWIP_CHECKSUM_CHECK_TCP
bool "CHECKSUM_CHECK_TCP"
default y 
help
	/**
	* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
	*/

config LWIP_CHECKSUM_ON_COPY
bool "LWIP_CHECKSUM_ON_COPY"
default n 
help
	/**
	* LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
	* application buffers to pbufs.
	*/


endmenu 


menu "Debugging options"

#config LWIP_DBG_MIN_LEVEL
#int "LWIP_DBG_MIN_LEVEL"
#help
#	/**
#	* LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
#	* compared against this value. If it is smaller, then debugging
#	* messages are written.
#	*/

#config LWIP_DBG_TYPES_ON
#int "LWIP_DBG_TYPES_ON"
#help
#	/**
#	* LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
#	* debug messages of certain types.
#	*/

config LWIP_ETHARP_DEBUG
bool "Enable debugging in etharp.c."
default n

config LWIP_NETIF_DEBUG
bool "Enable debugging in netif.c."
default n

config LWIP_PBUF_DEBUG
bool "Enable debugging in pbuf.c."
default n

config LWIP_API_LIB_DEBUG
bool "Enable debugging in api_lib.c."
default n

config LWIP_API_MSG_DEBUG
bool "Enable debugging in api_msg.c."
default n

config LWIP_SOCKETS_DEBUG
bool "Enable debugging in sockets.c."
default n

config LWIP_ICMP_DEBUG
bool "Enable debugging in icmp.c."
default n

config LWIP_IGMP_DEBUG
bool "Enable debugging in igmp.c."
default n

config LWIP_INET_DEBUG
bool "Enable debugging in inet.c."
default n

config LWIP_IP_DEBUG
bool "Enable debugging for IP."
default n

config LWIP_IP_REASS_DEBUG
bool "Enable debugging in ip_frag.c for both frag & reass."
default n

config LWIP_RAW_DEBUG
bool "Enable debugging in raw.c."
default n

config LWIP_MEM_DEBUG
bool "Enable debugging in mem.c."
default n

config LWIP_MEMP_DEBUG
bool "Enable debugging in memp.c."
default n

config LWIP_SYS_DEBUG
bool "Enable debugging in sys.c."
default n

config LWIP_TIMERS_DEBUG
bool "Enable debugging in timers.c."
default n

config LWIP_TCP_DEBUG
bool "Enable debugging for TCP."
default n

config LWIP_TCP_INPUT_DEBUG
bool "Enable debugging in tcp_in.c for incoming debug."
default n

config LWIP_TCP_FR_DEBUG
bool "Enable debugging in tcp_in.c for fast retransmit."
default n

config LWIP_TCP_RTO_DEBUG
bool "Enable debugging in TCP for retransmit  timeout."
default n

config LWIP_TCP_CWND_DEBUG
bool "Enable debugging for TCP congestion window."
default n

config LWIP_TCP_WND_DEBUG
bool "Enable debugging in tcp_in.c for window updating."
default n

config LWIP_TCP_OUTPUT_DEBUG
bool "Enable debugging in tcp_out.c output functions."
default n

config LWIP_TCP_RST_DEBUG
bool "Enable debugging for TCP with the RST message."
default n

config LWIP_TCP_QLEN_DEBUG
bool "Enable debugging for TCP queue lengths."
default n

config LWIP_UDP_DEBUG
bool "Enable debugging in UDP."
default n

config LWIP_TCPIP_DEBUG
bool "Enable debugging in tcpip.c."
default n

config LWIP_PPP_DEBUG
bool "Enable debugging for PPP."
default n

config LWIP_SLIP_DEBUG
bool "Enable debugging in slipif.c."
default n

config LWIP_DHCP_DEBUG
bool "Enable debugging in dhcp.c."
default n

config LWIP_AUTOIP_DEBUG
bool "Enable debugging in autoip.c."
default n

config LWIP_SNMP_MSG_DEBUG
bool "Enable debugging for SNMP messages."
default n

config LWIP_SNMP_MIB_DEBUG
bool "Enable debugging for SNMP MIBs."
default n

config LWIP_DNS_DEBUG
bool "Enable debugging for DNS."
default n


 endmenu 


