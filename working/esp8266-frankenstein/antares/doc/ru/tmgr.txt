tmgr: Простейший планировщик задач
----------------------------------

Описание
--------

Планировщик задач удобно использовать в том случае, если ваша программа логично
разбивается нa несколько отдельных потоков или циклично выполняемых блоков.
В таком случае планировщик предоставляет возможность сделать работу с потоками
максимально прозрачной.

Особенности
-----------

* Максимальная простота обращения с точки зрения пользователя

* Кроссплатформенность (реализация полностью на Си, без ассемблера)


Как использовать?
-----------------

1. Инициализация
----------------

Работа планировщика организуется циклическими вызовами двух функций:
tmgr_process() и tmgr_interrupt().

Функцию tmgr_interrupt() следует вызывать в обработчике прерывания таймера, который 
отсчитывает кванты времени планировщика. Оптимальным размером кванта времени 
автор считает 1 мс (соответственно, частота вызова функции tmgr_timer() будет
1 кГц). Эта функция обеспечивает только отсчёт времени (в зависимости от режима
работы планировщика) и минимально загружает систему в контексте прерывания.

Функцию tmgr_process() следует вызывать в основном цикле программы. В рамках вызова
этой функции будет происходить выполение задач пользователя, так что её вызов
в контексте прерывания не рекомендуется.

Для функции конвертирования времени требуется передать библиотеке значение частоты
системного таймера (в Гц). Это делается в меню настройки menuconfig, параметр
Scheduler timer frequency.

Замечание: Планировщик _не инициализирует_ таймер. Инициализация системного
таймера и организация вызовов функций планировщика лежит на пользователе.

Пример программы, обеспечивающей корректную работу таймера:

#include <lib/tmgr.h>

void SYSTEM_TIMER_IRQ()
{
        /* Прерывание системного таймера (абстрактно) */
        tmgr_interrupt();
}

int main(void)
{
        /* Инициализация системного таймера, платформо-зависима */
        SYSTEM_TIMER_INIT(1000);
        
        /* Вызов основной функции планировщика в бесконечном цикле */
        while (1)
                tmgr_process();

        return 0;
}

2. Работа с планировщиком
-------------------------

Для начала вам понадобится функция-обработчик, которая будет вызвана таймером.
Прототип функции:

        void my_handler(void *data);

Она принимает в качестве аргумента один указатель на void. Это можно
использовать для передачи какой-либо пользовательской информации обработчику
(например, для того, чтобы управлять контекстом выполнения задачи). Можно
оставить всё как есть, установив при инициализации таймера NULL в качестве
параметра. Этот параметр хранится в структуре таймера, задаётся при
(ре-)инициализации таймера.

Важно, чтобы данные, указатель на которые передаётся функции, хранились в
статической памяти. Никаких гарантий, что, если вы храните их на стеке
(в локальной переменной), в момент вызова обработчика в стеке будет именно
нужное значение.

Планировщику также требуется знать, когда запускать обработчик. 

Для хранения данных таймера, планировщику требуется немного _статической_
памяти. Можно объявить одну переменную типа tmgr_timer_t (структура) вручную,
а можно использовать встроенные макросы, облегчающие жизнь:

        TMGR_DEFINE_TIMER(timer_name, handler, data, expires);

Переменная будет называться timer_name, handler - название функции-обработчика,
data - указатель на данные, expires - таймстемп, в какое время (аптайм)
выполнить обработчик.

Если переменная должна быть static, просто допишите

        static TMGR_DEFINE_TIMER(timer_name, handler, data, expires);

После всей инициализации, для того, чтобы запустить таймер (добавить в очередь),
запускаем:

        tmgr_add_timer(&timer_name);

Для того, чтобы вручную не считать время для "запуска с задержкой", в качестве
'expires' можно записать так (сейчас, для примера, задержка на 1000 тиков):

        TMGR_DELAYED(1000)
или
        tmgr_get_uptime() + 1000

, что, в сущности, одно и то же.

Чтобы изменить таймер (пока он не в очереди), можно использовать макрос

        TMGR_SETUP_TIMER(timer_name, handler, data, expires);

Он просто обновляет значения в полях структуры.

Для того, чтобы удалить таймер из очереди, используем

        tmgr_del_timer(&timer_name);

После этого его можно спокойно перенастроить.

Для того, чтобы просто обновить время запуска, можно использовать

        tmgr_mod_timer(&timer_name, new_expires);

, если таймер сейчас в очереди.

В общем случае задержка запуска считается в тиках системного таймера. Для того,
чтобы выразить задержку в нормальных единицах времени, следует использовать
макросы конвертирования времени планировщика:

        tmgr_us_to_ticks(us)
        tmgr_ms_to_ticks(ms)
        tmgr_s_to_ticks(s)

Существуют также и макросы обратного конвертирования:
        
        tmgr_ticks_to_us(ticks)
        tmgr_ticks_to_ms(ticks)
        tmgr_ticks_to_s(ticks)

Время (число тиков, а также нормальных единиц) определяется типом данных
tmgr_uptime_t (целый знаковый, размер устанавливается пользователем в меню
конфигурации menuconfig). Таким образом, все функции конвертирования времени
принимают и возвращают tmgr_uptime_t.

Таким образом, вызов функции my_func с задержкой 500 мс будет выглядеть так:

        static TMGR_DEFINE_TIMER(my_timer, my_func, NULL, 
                                 TMGR_DELAYED(tmgr_ms_to_ticks(500)));
        tmgr_add_timer(&my_timer);


3. Режим работы планировщика
----------------------------

Основанием отсчёта времени является значение "времени
работы" (uptime) программы. При этом пользователь может в любой момент узнать
текущее значение uptime, вызвав функцию

        tmgr_get_uptime().

Функция возвращает тип tmgr_uptime_t (целочисленный знаковый, размер которого
устанавливается пользователем в меню конфигурации menuconfig).

Такой метод работы быстрее (в прерывании происходит только инкрементирование
значения переменной uptime, в основном цикле программы вызов задачи происходит
при совпадении текущего значения uptime с установленным при добавлении). 

Отсчитанное время хранится в переменной типа tmgr_time_t. Это целый знаковый тип,
размер которого можно установить в меню конфигурации menuconfig.
Возможно использование 32 и 64-битной переменной.

Предельное время стабильной работы в uptime-режиме в зависимости от размера
переменной (частота системного таймера - 1 кГц):

        32 бит - 2147483.65 с ~ 596 ч ~ 25 суток
        64 бит - 10^11 суток

4. Описание параметров планировщика (menuconfig)
------------------------------------------------

Time variable size
-----------------------
Размер переменной для хранения времени. (см. Режим работы).


5. Дополнительные возможности
-----------------------------

У планировщика есть функция tmgr_delay(delay). Она обеспечивает простую
задержку работы программы на нужный промежуток времени. В качестве единственного
аргумента функция принимает число тиков системного таймера, которые нужно
прождать. (С помощью функций конвертирования времени можно записывать время
задержки в стандартных единицах). Например, вызов

        tmgr_delay(tmgr_ms_to_ticks(500));

обеспечит остановку работы программы на 500 мс.

Принимаемый параметр имеет тип tmgr_time_t, неоднократно описанный выше.

Замечание. Использование этой функции с планировщиком НЕ РЕКОМЕНДУЕТСЯ.
Особенно в рамках вызываемых задач. Всё дело в том, что во время задержки
прерывается нормальное выполнение задач в планировщике (данный способ
задержки просто в цикле ждёт нужный момент времени, "подвешивая"
процессор.)

Функцию tmgr_get_fq() можно использовать для того, чтобы в любой момент
времени получить установленное ранее значение частоты системного таймера.
Возвращаемый тип - tmgr_time_t.
