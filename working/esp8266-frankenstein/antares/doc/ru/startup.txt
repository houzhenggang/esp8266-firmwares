Antares startup code
---------------------

CONFIG_ANTARES_STARTUP=y
CONFIG_LIB_INITCALL=y

Этот файл описывает примерное назначение antares startup кода и с чем
его надо употреблять.  Стартап код работает на всех архитектурах, где
есть gcc.

На данный момент это MSP430, AVR, ARM.

Зачем?
-------

Когда мы пишем что-то, что имеет подключаемые (например через kconfig)
куски, мы делаем так:

int main()
{
	init_spi()
	init_console();
	#ifdef CONFIG_SOMESTUFF
	enabled_liba();
	#endif
	...
} 

И тому подобное. Это неудобно, так как и печатать много, и для
добавления нового кусочка надо изменять сразу два файла - main.c, файл
который содержит тело функции, а в худшем случае еще и заголовочный
файл.  Но есть способ обойтись малой кровью и автоматически
сформировать группировать из нескольких файлов автоматически. Почти
так же как как работает device_initcall() в linux kernel.

Условно, процесс исполнения приложения мы можем представить вот таким
образом:

antares_init_low(); // Код инициализации до того, как будут включены глобально прерывания
antares_init_high(); //Код инициализации после того, как будут включены глобально прерывания  
while (1)
{
	antares_app(); //Код приложений. 
};


Для того, чтобы добавить код инициализации в группу antares_init_low() достаточно использовать
макрос ANTARES_INIT_LOW()

Например так: 
ANTARES_INIT_LOW(led_blink) 
{
	DDRA=0xff;
	PORTA=0xf0;
}

Таким образом мы можем объявлять сколько угодно функций
инициализации. Функции объявленные таким образом будут автоматически
исполнены в группе antares_init_low(); Аналогично, при помощи
ANTARES_INIT_HIGH можно добавить код в группу antares_init_high(); А
код для исполнения в главном цикле - через ANTARES_APP

Код приложений добавленных через ANTARES_APP будет выполняться в теле
бесконечного цикла.


А как насчет зависимостей? 
-------------------------- 

Как было замечено выше, порядок исполнения функций инициализиции, определяется
порядком линковки, на которой сложно/невозможно влиять... 
Так что задать зависимости на этапе компиляции невозможно/сложно.  
Для учета зависимостей при инициализации есть механизм INITCALL
Для это используются аналогичные вызывам выше макросы:  
ANTARES_INITCALL_LOW() and ANTARES_INITCALL_HIGH()
Они работают примерно также, но позволяют указывать Makefile-like зависимости. 
Пример: 

ANTARES_INITCALL_LOW(spi) 
{
	....			  
}

ANTARES_INITCALL_LOW(sd) 
{
	DEPENDS(spi);
	....
}
 
Заметки:
* Каждый объект инициализации будет вызван только ОДИН раз 
* От цикличных зависимостей никто не защитит. Не стреляйте себе в ногу.   
* HIGH и LOW initcall'ы не могут зависеть друг от друга. by design
* Для анализа результирующего порядка запуска - включите отладку. 


Как эта штука работает 
----------------------

По сути код макрос создает две функции. Функцию с именем, которое
передано аргументом макросу, и функцию-пустышку, которая только
вызывает ее, но объявляется с атрибутом naked, и помещается в
соответствующую секцию.  Пример для msp430:

#define ANTARES_INIT_LOW(fn)						\
	void fn();							\
	__attribute__((naked))						\
	__attribute__((__section__(".init5"))) void fn ## _low(void) {	\
		fn();							\
	};								\
	void fn() 

Соотвественно ANTARES_INIT_LOW(func) создаст две функции.  void func()
с нашим кодом, и void func_low(), которая будет без пролога/эпилога и
будет помещена в секцию .init5 Тот факт, что эти функции являются
naked, дает нам отсутствие инструкции возврата из функции, потому их
содержимое будет выполняться последовательно.  Мы не можем здесь
сэкономить на вызове функции, так как naked функции согласно
документации gcc очень ограничены: Нельзя использовать локальные
переменные, нельзя использовать if(), и т.п.  Более того, компилятор
не выдаст ошибки, и на некоторых архитектурах (avr) оно даже будет
работать, а в некоторых случаях (arm) будет давать
труднодиагностируемые баги на ровном месте.  Потому единственный здесь
способ выкрутиться - свести naked часть к вызову пользовательской
функции.


SDCC?
-----

К сожалению, при использовании SDCC такое реализовать очень сложно,
если вообще Во-первых потому, что SDCC рассматривает результат сборки
одного файла как один объект для линковки, и помещать отдельные
функции в отдельные секции нельзя. Только весь файл.
Если Вы знаете как это сделать - пришлите патч!
